# Отчет по лабораторной работе
## по курсу "Функциональное и логическое программирование"

**Студенты:**
| ФИО |  Роль в проекте |
|-|-|
| Былькова К. А. | Разработка парсера, написание отчета |
| Немкова А. Р. | Разработка интерпретатора, обработка ошибок |
| Старостина А. А. | Разработка синтаксического дерева, написание отчета |

## Цель работы

Придумать свой собственный функциональный язык программирования и разработать для него интерпретатор или компилятор.

## Язык gg

Нами был придуман и написан язык gg. Он следует парадигме функционального программирования на основе лямбда-исчисления. Также наш язык позволяет запрограммировать функцию для расчета факториала. Комментарии в нашем языке выделяются с помощью знака #. Следует отметить, что синтаксис нашего языка требует, чтобы анализируемые деревья имели только один корень, поэтому все языковые программы имеют дополнительные внешние скобки.
Также было создано расширение для VSCode.

## Документация

[Руководство по использованию языка](https://aannnssss.github.io/DOCUMENTATION/)

## Реализованные функции

Здесь представлены функции, которые реализованы в нашем языке.
* Именованные переменные (`var`)
* Рекурсия
* Функции
* Замыкания
* Библиотечные функции: ввод-вывод файлов

## Синтаксическое дерево

Структура нашего синтаксического дерева основана на комбинировании узлов Expr. Например, операторы и их операнды объединяются в узлы OPERATOR, цикл for представляется в узле FOR_LOOP, цикл while в узле WHILE, а условные выражения - узлами COND.


Благодаря тому, что узлы дерева могут включать в себя друг друга, у нас есть возможность комбинировать их и представлять сложные структуры и выражения. Ниже представлены реализованные структуры.
| Тип | Описание |
|-|-|
| OPERATOR | Операторы и списки параметров |
| NUMBER | Числовые значения |
| STRING | Строковые значения |
| ID | Именованные переменные |
| BOOL | Булевые значения |
| COND | Условные выражения |
| FUNC | Функции |
| CALL | Вызов функции |
| PRINT | Печать |
| READ_FILE | Чтение файла |
| WRITE_FILE | Запись в файл |
| FOR_LOOP | Цикл for |
| WHILE | Цикл while |
| CONTINUE | Продолжение цикла |
| KILL | Остановка цикла |

## Парсер

Наш парсер принимает на вход строки, разделяя их на отдельные части и создавая список токенов, затем преобразует его во внутреннюю структуру данных, представляющую синтаксическое дерево нашего языка. Мы определяем ключевые слова и сопоставляем их с соответствующими шаблонами. Токены, представляющие идентификаторы, числа, строки и операторы, преобразуются в соответствующие структуры данных. Мы также обрабатываем структуры, описывающие блоки кода (функции, условные операторы, циклы). При разборе идентификаторов они добавляются в аккумулирующий список до обнаружения правой фигурной скобки, что позволяет парсеру учитывать идентификаторы внутри фигурных скобок. Если парсер обнаруживает ошибки в синтаксисе, он генерирует исключения. В результате мы получаем структуру данных, которую далее можно использовать для интерпретации нашего языка.
## Интерпретатор
Наш интерпретатор представляет собой модуль F#, который обрабатывает выражения, представленные в виде абстрактного синтаксического дерева, составленного парсером. Структура интерпретатора начинается с функции eval, которая принимает окружение (env) и выражения (expr) для оценки. Выражения синтаксического дерева разбираются по типам данных: числовым операциям, логическим операциям и бинарным операциям. 

Функции eval_args_bool и eval_args_num обрабатывают аргументы логических и числовых операций соответственно, возвращая их вычисленные значения. 

Функция eval_implem рекурсивно вычисляет значения выражений и операторов, учитывая их типы и аргументы. 

Для условных выражений и циклов реализованы соответствующие ветви COND и FOR_LOOP, позволяющие управлять выполнением кода в зависимости от условий. Цикл WHILE позволяет выполнять блок кода до тех пор, пока условие остается истинным. Интерпретатор также обрабатывает исключения ControlFlow для управления потоком выполнения, таких как Break и Continue в циклах.

Структура данных Map используется для хранения и поиска операций и их реализаций. Вычисленные значения возвращаются вместе с обновленным окружением, чтобы сохранить состояние переменных между вычислениями. 

При вызове операции PRINT происходит вычисление выражения внутри него, затем выводится результат на экран в зависимости от его типа (число, строка, логическое значение или идентификатор). Операция READ_FILE считывает текст из файла и возвращает его в виде строки. Операция WRITE_FILE записывает данные в указанный файл.
## Примеры
* Строки

Строковые литералы объявляются как строка, обернутая двойными кавычками.
```
(var str = "Hello world")
(print str)
```
Вывод:
```
Hello world
```
* Простейшие операции

В нашем языке порддерживаются следующие математические операции: +, *, /, -. Числа представляются типом float. Математические операции всегда окружаются круглыми скобками, внутри которых для этих операций передаются аргументы. Аргументов может быть от одного и более. При передаче лишь одного аргумента x вызываются соответственно функции x, x, (1 / x), -x. В случае передачи множества аргументов первый из них выступает в роли начального, а после происходит свёртка списка аргументов (например, (- a b c) превращается в a - b - c).
```
(var a = 2.0)
(var c = 10.0)
(print (+ a c))
(print (* a c))
(print (/ c a))
(print (- c a))
```
Вывод:
```
12.000000
20.000000
5.000000
8.000000
```
* Булевыe операции

Доступны две булевые операции: оператор «И» (обозначенный &) и оператор «ИЛИ» (обозначенный |). Булевые константы записываются 1 - true и 0 - false.
```
(print (& 1 0))
(print (| 0 0))
```
Вывод:
```
false
false
```
* Условия

Для создания условного выражения нужно воспользоваться синтаксисом - (if Cond : Expr else : Expr) или (if Cond :). При вызове будет оценено выражение, стоящее после if, а вернется Expr.
```
(
    if(== 2 3) :
        (print "true")
    else :
        (print "false")
)
```
Вывод:
```
false
```
* Цикл for

Для создания цикла for нужно воспользоваться синтаксисом - (for i [from .. to] : Expr). При вызове будет переменная i будет принимать значения из отрезка from .. to.
```
(for i [0 .. 3] :
        (print i)
)
```
Вывод:
```
0.000000
1.000000
2.000000
```
* Цикл while

Для создания цикла while нужно воспользоваться синтаксисом - (while Cond : Expr). Цикл будет выполняться, пока Cond истинно. Также поддерживаются операторы continue и kill (break). 
```
(
    func fun {s} :
  	(   
        while (< s 10) :
            ((print s) 
            (fun (+ s 1)))
    )
) 

(fun 1)
```
Вывод:
```
1.000000
2.000000
3.000000
4.000000
5.000000
6.000000
7.000000
8.000000
9.000000
```
* Работа с файлами

Работа с файлами производится с помощью команд read и write (чтение и запись соответственно). Для чтения необходимо подать название файла в двойных кавычках, а для записи - название файла и текст, который необходимо записать.
```
(print(read "./test.txt"))
(write "./output.txt" "MEOW")
```
Вывод:
```
Hello!
```
* Факториал

Наш язык позволяет запрограммировать функцию для расчета факториала.
```
(func fact {n} :
    (if(== n 0) :
            1
        else :
            (* n (fact (- n 1)))
    )
)
(print (fact 5))
```
Вывод:
```
120.000000
```
## Заключение

В результате данной лабораторной работы был придуман и написан функциональный язык программирования, позволяющий выполнять простейшие операции над числами и строками. Также были реализованы условия, циклы, рекурсия и возможна работа с файлами. 

Первым этапом нашей работы было создание парсера, который преобразует входной текст программы в абстрактное синтаксическое дерево. Этот процесс включал в себя разбор строки и создание структуры данных, представляющей синтаксическую структуру программы. Затем был разработан интерпретатор, способный выполнять программы, представленные в виде абстрактного синтаксического дерева. Интерпретатор обрабатывает различные типы выражений, выполняя соответствующие операции в зависимости от их типа. В итоге была реализована общая структура компилятора, который может принимать входные программы, разбирать их, а затем выполнять или преобразовывать в другие формы.

Таким образом, выполнение данной работы позволило углубить наши знания о языке программирования F# и его возможностях, а также ознакомиться с основными принципами разработки. Были получены знания о том, как писать свой собственный парсер и интерпретатор, что однозначно пригодится в будущем при выполнении других курсовых и лабораторых работ.
